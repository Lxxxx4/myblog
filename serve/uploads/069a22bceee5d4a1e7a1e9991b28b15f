## nodejs最主要的两大特点

> nodejs设计最初是为了创造一个高性能的web服务器，为了满足
>
> - 事件驱动
> - 非阻塞I/O

#### 异步I/O

> 发出请求后，立即执行后端代码，再接受到响应后执行其回调。再node中，绝大多数的操作都是异步的。这样的好处是node可以并行的处理其他操作。

#### 事件驱动

> 优势：轻量级，松耦合，只关注事务。

#### 单线程

> 优势：无需和其余线程共享状态。也无需关心多线程编程中的同步问题。
>
> 劣势：
>
> - 无法利用多核cpu
> - 错误会引起整个应用退出
> - 大量计算占用cpu导致无法继续调用异步I/O
>
> node解决单线程中大量计算的问题：
>
> ​	通过将计算分发到各个子进程，再通过各个进程之间的事件消息来传递结果

#### node的应用场景

- I/O密集型

  > node利用事件循环的处理能力，而不是启动每一个线程未每一个请求服务，资源占用极少

- 执行CPU密集型任务时的性能也比较可观

  > Node带来的高性能I/O用于实时应用(实时通信)
  >
  > 并行I/O使得可以更加高效的利用分布式环境
  >
  > 并行I/O，有效利用稳定接口提升web渲染能力(加速数据的获取)

#### node的模块机制

##### CommonJS 规范

> CommonJS 对模块的定义：
>
> 主要分为三个部分
>
> - 模块引用 require()方法，这个方法接受木块标识，以此来引入一个模块的埃皮刀当前上下文
> - 模块定义 上下文提供了exports对象用来到处当前模块的方法或者变量，并且他们时**唯一的导出的出口**，在模块中还存在一个module对象，它代表模块本身，而exports时module的属性，在node中，一个文件就是一个模块将犯法挂载到exports对象上作为属性即可定义到处的方式。在另一个文件中，就可以调用定义的属性或方法了
> - 模块标识 就是传递给require()方法的参数，必须符合小驼峰命名的字符串，或者相对路径或者绝对路径，可以没有js后缀。

##### 模块的实现

> 经历了三个步骤：
>
> - 路径分析
> - 文件定位
> - 编译执行
>
> 模块分为：核心模块和用户模块
>
> 核心模块：
>
> - 核心模块部分早Node源代码的编译过程中，编译进了二进制的执行文件。在node进程启动时，部分核心模块就被直接加载进内存中去了，所以文件定位和编译执行这两个步骤可以省掉，并且在路径分析中优先判断，它的加载速度时最快的
> - 文件模块则在运行时动态加载，需要完整的路径分析，文件定位和编译执行
>
> 加载过程：
>
> 优先从缓存中加载 对于已经加载过的模块进行缓存以减少二次引入的开销，node缓存的时编译和执行的对象。而浏览器缓存的仅仅是文件







## node全局变量

#### process

> process 对象是一个 global （全局变量），提供有关信息，控制当前 Node.js 进程。作为一个对象，它对于 Node.js 应用程序始终是可用的，故无需使用 require()。

##### **process.env**

> process.env属性返回一个包含用户环境信息的对象。
>
> 配置**环境变量**，在**Windows**在我的电脑配置永久配置。也可用在cmd配置临时配置
>
> ```javascript
> #node中常用的到的环境变量是NODE_ENV，首先查看是否存在
> set NODE_ENV
> #如果不存在则添加环境变量
> set NODE_ENV=production
> #环境变量追加值 set 变量名=%变量名%;变量内容
> set path=%path%;C:\web;C:\Tools
> #某些时候需要删除环境变量
> set NODE_ENV=
> ```
>
> 在linux中，临时配置
>
> ```javascript
> #node中常用的到的环境变量是NODE_ENV，首先查看是否存在
> echo $NODE_ENV
> #如果不存在则添加环境变量
> export NODE_ENV=production
> #环境变量追加值
> export path=$path:/home/download:/usr/local/
> #某些时候需要删除环境变量
> unset NODE_ENV
> #某些时候需要显示所有的环境变量
> env
> ```
>
> 永久配置
>
> ```javascript
> 打开配置文件所在
> # 所有用户都生效
> vim /etc/profile
> # 当前用户生效
> vim ~/.bash_profile
> 
> 在文件末尾添加类似如下语句进行环境变量的设置或修改
> # 在文件末尾添加如下格式的环境变量
> export path=$path:/home/download:/usr/local/
> export NODE_ENV = product
> 
> 最后修改完成后需要运行如下语句令系统重新加载
> # 修改/etc/profile文件后
> source /etc/profile
> # 修改~/.bash_profile文件后
> source ~/.bash_profile
> ```
>



#### 构造函数

> 在构造函数中，如果实例被创建，this指向这个实例。
>
> this 是动态绑定，或称为运行期绑定的，它可以是全局对象、当前对象或者任意对象，这取决于函数的调用方式
>
> instanceof 用来判断一个实例是否属于某种类型
>
> ```javascript
> this instanceof  Vue  //如果是用new来操作的话，结果为true
> ```

构造函数其实和普通函数本质上并无区别，唯一的区别有两个：
- 函数首字母大写，这个区别只是约定俗成的，便于区分。
- 构造函数的调用需要用new操作符，而普通函数的调用又分很多种，但是都不会用到new操作符。所以，构造函数和普通函数的区别就在这个new操作符里，现在让我们来好好研究一下这个new操作符。

用new操作符创建对象时发生的事情：
- 创建一个Object对象实例。
- 将构造函数的执行对象赋给新生成的这个实例。
- 执行构造函数中的代码
- 返回新生成的对象实例

#### 函数柯里化
> 把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且**返回**接受余下的参数而且返回结果的**新函数**的技术。
> 就是只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。


##### 好处
1. 参数复用
```JS
// 一个正则的例子，curring化后
function curryingCheck(reg) {
    return function(txt) {
        return reg.test(txt)
    }
}
var hasNumber = curryingCheck(/\d+/g)
hasNumber('test1')      // true
```